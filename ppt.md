---
marp: true
theme: custom
class: lead
paginate: true
---

<!---
_class: title
--->
> # 소프트웨어 개발을 위한 프롬프트 엔지니어링
> 
### AI & Core Tech LAB

<aside>page: 1</aside>

---

> 소프트웨어 개발을 위한 프롬프트 엔지니어링
<br />
# 프롬프트 엔지니어링 개요
<br /><br />

<aside>page: 2</aside>

---
<!-- _header: 프롬프트 엔지니어링 개요 -->

## **프롬프트 엔지니어링**
- AI 모델, 특히 대형 언어 모델(LLM)에 명확하고 효과적인 지침을 제공하여 원하는 출력을 얻는 과정
<br />
  
소프트웨어 개발에서:
  - 코드 생성
  - 디버깅
  - 테스트 자동화
  - 문서화

![bg right:30% height:200]()
<!-- _footer: "" -->

<aside>page: 3</aside>

---
<!-- _header: 프롬프트 엔지니어링 개요 -->

## 프롬프트 엔지니어링의 중요성
<br />

- AI 모델 성능은 **프롬프트 품질**에 의존
- 효과적인 프롬프트 작성은 출력의 **정확성, 관련성, 유용성**을 결정
- 소프트웨어 개발에서:
  - 코드 생성 품질 향상
  - 개발 생산성 및 코드 품질에 직접적 영향
<!-- _footer: "" -->

<aside>page: 4</aside>

---
<!-- _header: 프롬프트 엔지니어링 개요 -->

## 소프트웨어 개발에서의 적용 영역
<br />

- 코드 생성 및 리팩토링
- 버그 탐지 및 디버깅
- 테스트 코드 작성
- 문서화
- 요구사항 분석 및 설계
- 코드 리뷰
<!-- _footer: "" -->

<aside>page: 5</aside>

---
<!-- _header: 프롬프트 엔지니어링 개요 -->

<div class="two-blocks">
<div class="block">


## 프롬프트 엔지니어링의 기본 원칙
<br />

- **명확성과 구체성**: 원하는 결과물에 대한 명확한 지시
- **단계별 지시**: 복잡한 작업을 논리적 단계로 분해
- **맥락 제공**: 작업 배경과 목적 정보 제공
- **제약 조건 명시**: 기술적/기능적 요구사항 명시
- **예시 제공**: 출력 형태 예시 포함
</div>  

<div class="block">  

![](https://i.imgur.com/sKOgWU8.png)
</div>  
</div>

<!-- _footer: "" -->

<aside>page: 6</aside>

---

> 소프트웨어 개발을 위한 프롬프트 엔지니어링
<br />
# 소프트웨어 개발에서의 AI 도입 이점
<br /><br />

<aside>page: 7</aside>

---
<!-- _header: 소프트웨어 개발에서의 AI 도입 이점 -->

## **소프트웨어 개발에서의 AI 도입**
<br />

소프트웨어 개발 분야에서 AI, 특히 대형 언어 모델(LLM)을 도입하는 것은:
- 단순한 도구 추가를 넘어 개발 패러다임의 전환
- 개발 생명주기 전반에 걸쳐 개발자의 역량 확장
- 팀의 효율성 향상 및 최종 제품의 품질 향상

<!-- _footer: "" -->

<aside>page: 8</aside>

---
<!-- _header: 소프트웨어 개발에서의 AI 도입 이점 -->

<div class="two-blocks">
<div class="block">
<h2>개발 생산성 향상</h2>

- **코드 생성 가속화**: 반복적인 코드 작성 시간 90%까지 단축
- **지식 접근성 개선**: 학습 곡선 크게 단축
- **워크플로우 최적화**: 개발 주기 평균 30-40% 단축
- **문맥 전환 최소화**: 핵심 개발 업무 집중도 향상
- **인지 부하 감소**: 복잡한 구현 시 인지적 부담 감소
</div>
<div class="block">
<h2>코드 품질 향상</h2>
  
- **오류 예방 및 감지**: 버그 발견률 40%까지 감소
- **코드 일관성 및 표준 준수**: 기술 부채 축적 방지
- **테스트 커버리지 향상**: 테스트 커버리지 50-60% 향상
- **코드 리뷰 심층화**: 심층적 논리적 오류 식별
- **유지보수성 개선**: 장기적인 유지보수 비용 감소
</div>
</div>

<!-- _footer: "" -->

<aside>page: 9</aside>

---
<!-- _header: 소프트웨어 개발에서의 AI 도입 이점 -->

<h2>개발 비용 절감</h2>
<br />

- **인력 자원 최적화**: 동일 산출물 인력 리소스 30%까지 절감
- **출시 기간 단축**: 시장 출시 시간 감소로 경쟁 우위 확보
- **기술 부채 감소**: 유지보수 비용 25-35% 절감
- **개발자 온보딩 가속화**: 온보딩 시간 50%까지 단축
- **개발 환경 통합**: 도구 전환 비용과 학습 비용 감소

<!-- _footer: "" -->

<aside>page: 10</aside>

---

> 소프트웨어 개발을 위한 프롬프트 엔지니어링
<br />
# 효과적인 프롬프트 엔지니어링 기법
<br /><br />

<aside>page: 11</aside>

---
<!-- _header: 효과적인 프롬프트 엔지니어링 기법 -->

## **Few-shot 프롬프팅 기법**

- AI에게 몇 가지 예시를 제공하여 원하는 결과물의 형태를 학습시키는 방법
- 예시를 통해 원하는 출력 형식과 스타일을 명확히 전달
- 복잡한 패턴이나 형식을 요구하는 작업에 효과적
- 모델이 예시로부터 패턴을 인식하고 유사한 결과물 생성 가능
![bg right:37% height:470](https://i.imgur.com/KNWCqqb.png)
예시 : 
```
다음은 REST API 컨트롤러의 예시입니다:

@RestController
@RequestMapping("/api/users")
public class UserController {
   @GetMapping("/{id}")
   public ResponseEntity<User> getUser(@PathVariable Long id) {
       // 구현 내용
   }
}
위 예시를 참고하여, 상품(Product) 정보를 관리하는 REST API 컨트롤러
를 작성해주세요.
```
</div>
<!-- _footer: "" -->

<aside>page: 12</aside>

---
<!-- _header: 효과적인 프롬프트 엔지니어링 기법 -->

## **단계별 프롬프팅 방법론**
<br />

- 복잡한 작업을 작은 단계로 나누어 AI가 순차적으로 처리하도록 하는 방법
- 각 단계별 명확한 지시를 제공하여 정확도 향상
- 복잡한 소프트웨어 개발 과정에 적합
- 중간 결과를 검토하고 수정할 기회 제공

![bg right:37% height:470](https://i.imgur.com/lIynP3c.png)
예시:

```
1단계: 사용자 인증 기능을 위한 데이터 모델을 설계해주세요.
2단계: 1단계에서 설계한 모델을 기반으로 사용자 등록 API를 구현해주세요.
3단계: JWT를 사용한 로그인 기능을 추가해주세요.
```

<!-- _footer: "" -->

<aside>page: 13</aside>

---
<!-- _header: 효과적인 프롬프트 엔지니어링 기법 -->

## **템플릿 접근법 활용**
<br />

- 반복적으로 사용할 수 있는 프롬프트 템플릿을 개발하는 방법
- 일관된 형식으로 AI에게 정보 제공
- 필요한 정보를 체계적으로 구조화
- 팀 내에서 표준화된 프롬프트 패턴 확립 가능

![bg right:37% height:470](https://i.imgur.com/f7LM21y.png)

예시:
```
[코드 목적]: <코드가 수행해야 할 기능>
[기술 스택]: <사용할 프로그래밍 언어, 프레임워크, 라이브러리>
[제약 조건]: <성능, 보안, 호환성 등의 제약 조건>
[예상 출력]: <코드 실행 시 예상되는 결과>
```

<!-- _footer: "" -->

<aside>page: 14</aside>

---
<!-- _header: 효과적인 프롬프트 엔지니어링 기법 -->

## **사고 연쇄(Chain-of-Thought) 프롬프팅**
<br />

- AI가 논리적 사고 과정을 단계별로 보여주며 문제를 해결하도록 유도하는 기법
- AI가 주체가 되어 추론 과정을 명시적으로 드러냄
- 복잡한 문제 해결 과정의 투명성 확보
- 설계 문제, 알고리즘 개발, 아키텍처 결정에 특히 유용

![bg right:37% height:470](https://i.imgur.com/HP3YQuf.png)


예시:
```
다음 객체지향 설계 문제에 대해 단계별로 사고 과정을 보여주며 
해결해주세요:

"온라인 도서관 시스템을 설계하려고 합니다. 이 시스템은 도서 관리, 
회원 관리, 
대출 관리 기능이 필요합니다. SOLID 원칙을 적용하여 주요 클래스와 
인터페이스를 설계해주세요."
```

<!-- _footer: "" -->

<aside>page: 15</aside>

---
<!-- _header: 효과적인 프롬프트 엔지니어링 기법 -->

## **도메인 특화 어휘 활용**
<br />

- 특정 기술 영역의 전문 용어와 개념을 프롬프트에 포함
- AI가 해당 컨텍스트를 정확히 이해하고 관련 지식을 활용하도록 유도
- 도메인 특화 솔루션 개발 시 정확성과 적합성 향상
- 특정 프레임워크나 기술 스택에 특화된 코드 생성에 효과적

![bg right:37% height:470](https://i.imgur.com/eYucsXV.png)

예시:
```
Spring Batch를 사용하여 대량의 거래 데이터를 처리하는 배치 작업을 구
현해주세요. 
다음 요소를 포함해야 합니다:

- ItemReader: 데이터베이스에서 페이징 방식으로 데이터를 읽어오는 Jdb
cPagingItemReader 사용
- ItemProcessor: 거래 데이터를 가공하고 유효성 검사를 수행하는 커스텀 
프로세서
- ItemWriter: 처리된 데이터를 별도 테이블에 저장하는 JdbcBatchItemWr
iter 구현
- ChunkSize: 1,000개 단위로 처리
```

<!-- _footer: "" -->

<aside>page: 16</aside>


---
<!-- _header: 효과적인 프롬프트 엔지니어링 기법 -->

## **제약 조건 기반 프롬프팅**
<br />

- 명확한 제약 조건과 가이드라인을 설정하여 AI의 응답을 제어하는 방법
- 결과물의 품질과 적합성을 높이기 위한 경계 설정
- 특정 요구사항과 기술적 제약에 부합하는 결과물 유도
- 복잡한 소프트웨어 개발 요구사항 구현에 효과적

![bg right:37% height:470](https://i.imgur.com/KUozQgf.png)

예시:
```
다음 제약 조건을 만족하는 Spring Boot 애플리케이션의 보안 구성을 작성
해주세요:
- 모든 API는 JWT 기반 인증을 사용해야 합니다
- 비밀번호는 최소 8자 이상이어야 하며, 대소문자, 숫자, 특수문자를 포
함해야 합니다
- 사용자 역할은 ADMIN, USER, GUEST로 구분해야 합니다
- CORS 설정은 특정 도메인만 허용해야 합니다
- 모든 인증 실패는 로그로 기록되어야 합니다
```

<!-- _footer: "" -->

<aside>page: 17</aside>

---
<!-- _header: 효과적인 프롬프트 엔지니어링 기법 -->

## **반복적 개선(Iterative Refinement) 기법**
<br />

- 초기 결과물을 기반으로 점진적으로 개선해 나가는 방법
- 여러 차례의 상호작용을 통해 최종 결과물의 품질 향상
- 실제 소프트웨어 개발 과정과 유사한 점진적 접근법
- 복잡한 개발 작업의 단계적 구현 가능

![bg right:37% height:470](https://i.imgur.com/uVGHQJh.png)

예시:
```
[초기 요청] "회원 가입 기능을 구현하는 Spring Boot 컨트롤러를 작성해
주세요."

[검토 후 개선 요청] "작성해 주신 코드에 이메일 중복 검사 기능과 비밀
번호 
유효성 검사 기능을 추가해주세요."

[추가 개선 요청] "유효성 검사 실패 시 클라이언트에게 적절한 오류 메시
지를 
반환하도록 개선해주세요. 또한 회원 가입 성공 시 환영 이메일을 전송하
는 비동기 기능을 추가해주세요."
```

<!-- _footer: "" -->

<aside>page: 18</aside>

---

> 소프트웨어 개발을 위한 프롬프트 엔지니어링
<br />
# 소프트웨어 개발에서의 프롬프트 엔지니어링 활용 영역
<br /><br />

<aside>page: 19</aside>

---
<!-- _header: 소프트웨어 개발에서의 프롬프트 엔지니어링 활용 영역 -->

## **소프트웨어 개발을 위한 프롬프트 설계 전략**
<br />

1. **기술 스택 상세화**: 프레임워크, 언어, 라이브러리와 그 버전 명시
2. **요구사항 카테고리화**: 기능적, 비기능적, 기술적 요구사항으로 구분
3. **구조 제공**: 참고할 코드 구조나 엔티티 관계 제시로 맥락 이해 지원
4. **구체적 예시 제공**: API 요청/응답 형식, 메소드 시그니처 등 형태 제시
5. **제약조건 명시**: 성능, 보안, 호환성 등 제약사항 명확화
6. **명확한 목표 설정**: 코드의 구체적인 목적과 기능 명시
7. **맥락 제공**: 코드가 사용될 환경, 의존성 정보 제공
8. **예시 또는 참조 제공**: 비슷한 기능의 코드 예시나 문서 링크 제공

<!-- _footer: "" -->

<aside>page: 20</aside>

---

<!-- _header: 소프트웨어 개발에서의 프롬프트 엔지니어링 활용 영역 -->

## 개발 생명주기별 프롬프트 활용

- **요구사항 분석**: "다음 사용자 스토리에서 기능적 요구사항과 비기능적 요구사항을 분류해주세요"
- **설계**: "다음 요구사항에 맞는 마이크로서비스 아키텍처를 설계해주세요"
- **코드 생성**: "숫자의 팩토리얼을 계산하는 Python 함수를 생성해 주세요"
<br />

- **테스트**: "이 함수에 대한 단위 테스트를 작성해 주세요"
- **디버깅**: "이 코드 조각의 버그를 찾아 수정해 주세요"
- **문서화**: "이 코드 섹션에 대한 설명을 작성해 주세요"
- **배포**: "다음 애플리케이션을 AWS에 배포하기 위한 CI/CD 파이프라인 설정 방법을 설명해주세요"

<!-- _footer: "" -->

<aside>page: 21</aside>

---

<!-- _header: 소프트웨어 개발에서의 프롬프트 엔지니어링 활용 영역 -->

## **코드 생성 및 리팩토링**
<br />

- **구조화된 기술 명세 스타일**: 요구사항을 명확한 목록 형태로 제시
```
다음 요구사항에 맞는 Java 코드를 작성해주세요:
- Spring Boot 기반 REST API 엔드포인트
- 사용자 정보를 조회하는 GET 메서드
```
- **역할 기반 대화형 스타일**: AI에게 특정 역할과 맥락을 부여
```
Act as a software engineer. You're an expert in Python and AWS. 
I want you to develop software to manage my record collection.
Make it a web-based application written in Python.
```
<!-- _footer: "" -->

<aside>page: 22</aside>

---
<!-- _header: 소프트웨어 개발에서의 프롬프트 엔지니어링 활용 영역 -->
<div class="grid-three-blocks"> <div class="block2" style="margin:2px; font-size:90%">
    
## 버그 탐지 및 디버깅 활용

다양한 유형의 버그/보안 취약점 검출 가능
<br />

```
다음 코드에서 발생할 수 있는 버그와 보안 취약점을 찾
고, 수정 방법을 제안해주세요:
[코드 첨부]
특히 SQL 인젝션, XSS 취약점, 메모리 누수 가능성에 주목해주세요.
```
</div>
  <div class="block2" style="margin:2px; font-size:90%">

<h2>테스트 코드 생성 접근법</h2>
Testcase 자동 생성- 테스트 커버리지 향상
<br />
<br />

```
다음 JavaScript 함수에 대한 Jest 테스트 코드를 작성해주세요:
- 기본 기능 테스트
- 경계값 테스트
- 예외 상황 테스트
- 모킹이 필요한 경우 예시 포함

[함수 코드 첨부]
```
</div>
  <div class="block2" style="margin:2px; font-size:90%">

<h2>문서화 지원</h2>

코드 문서화 자동화 - 일관성, 완성도 향상
<br />

```
다음 Python 함수에 대한 상세한 docstring을 작성해주세요.
파라미터, 반환값, 예외처리, 사용 예시를 포함해야 합니다.
Google 스타일 가이드를 따라주세요.

[함수 코드 첨부]
```
</div>
</div>

<!-- _footer: "" -->

<aside>page: 23</aside>

---


> 소프트웨어 개발을 위한 프롬프트 엔지니어링
<br />
# 상황별 프롬프트 예제
<br /><br />

<aside>page: 24</aside>

---

<!-- _header: 상황별 프롬프트 예제 -->

## **예제 1: REST API Endpoint URL과 데이터모델 클래스 생성**

**프롬프트 개선 예시**:
```
"온라인 쇼핑몰의 주문 관리 시스템을 위한 RESTful API 엔드포인트와 
필요한 데이터 모델 클래스를 설계해주세요. 주문 생성, 
조회, 수정, 취소 기능이 필요합니다."
```

**개선 후**:
```
"Spring Boot 2.7, Java 11, JPA를 사용하여 온라인 쇼핑몰의 주문 관리 시스템을 위한
RESTful API 엔드포인트와 필요한 데이터 
모델 클래스를 설계해주세요.

요구사항:
- 주문 생성, 조회, 수정, 취소 기능 구현
- 주문은 주문ID, 고객정보, 주문상품목록, 총금액, 주문상태, 주문일시 정보를 포함
- 주문상품은 상품ID, 수량, 단가 정보를 포함
- 주문상태는 결제대기, 결제완료, 배송준비, 배송중, 배송완료, 취소됨 상태 관리
```
<aside>  page: 25</aside>
<!-- _footer: "" -->

---
<!-- _header: 상황별 프롬프트 예제 -->

## **예제 2: 복잡한 JPA Query 작성**
  
**프롬프트 개선 예시**:
```
"사용자의 주문 내역을 조회하는 복잡한 JPA Query를 작성해주세요. 주문 상태, 날짜 범위
, 금액 범위로 필터링이 가능해야 합니다."
```

**개선 후**:
```
"Spring Boot 2.7과 Spring Data JPA를 사용하여 사용자의 주문 내역을 조회하는 복잡한 
JPA Query를 작성해주세요.

기술 요구사항:
- QueryDSL 또는 JPQL을 사용한 구현
- 다음 필터링 조건 지원: 주문 상태, 주문 날짜 범위, 총 금액 범위
- 페이징 처리(페이지 번호, 페이지 크기)
- 정렬 기능(주문일, 금액, 상태 기준)

성능 요구사항:
- N+1 문제 방지를 위한 fetch join 사용
- 인덱스 활용을 고려한 쿼리 설계
```

<!-- _footer: "" -->

<aside>page: 26</aside>

---
<!-- _header: 상황별 프롬프트 예제-->

## **예제 3: API 오류 처리 미들웨어 구현**

**프롬프트 개선 예시**:
```
"REST API에서 발생할 수 있는 다양한 예외(유효성 검증 오류, 리소스 없음, 인증 오류, 
서버 오류)를 처리하는 글로벌 예외 
핸들러를 Spring Boot에서 구현해주세요."
```

**개선 후**:
```
"Spring Boot 3.0 애플리케이션에서 REST API의 전역 예외 처리를 위한 GlobalException
Handler를 구현해주세요.

요구사항:
- @ControllerAdvice 또는 @RestControllerAdvice 사용
- 다음 예외 유형별 처리 로직 구현:
  1. ValidationException: 요청 데이터 유효성 검증 실패 (400 Bad Request)
  2. ResourceNotFoundException: 요청한 리소스가 존재하지 않음 (404 Not Found)
  3. UnauthorizedException: 인증 실패 (401 Unauthorized)
  4. ForbiddenException: 권한 부족 (403 Forbidden)
```

<!-- _footer: "" -->

<aside>page: 27</aside>

---
<!-- _header: 상황별 프롬프트 예제 -->

## **예제 4: 데이터베이스 트랜잭션 관리**

**프롬프트**:
```
"Spring Boot 2.7과 Spring Data JPA를 사용하여 은행 계좌 간 이체 서비스의 트랜잭션 
관리 로직을 구현해주세요.

비즈니스 요구사항:
- 출금 계좌에서 금액 차감
- 입금 계좌에 금액 추가
- 거래 내역 기록
- 모든 작업이 하나의 트랜잭션으로 처리되어야 함

기술 요구사항:
- @Transactional 어노테이션을 사용한 선언적 트랜잭션 관리
- 롤백 조건 명시 (잔액 부족, 계좌 존재하지 않음 등)
- 트랜잭션 격리 수준 설정 (READ_COMMITTED 이상)
- 낙관적 락(Optimistic Locking)을 사용한 동시성 제어
```

<!-- _footer: "" -->

<aside>page: 28</aside>

---
<!-- _header: 상황별 프롬프트 예제 -->

## **예제 5: 단위 테스트 작성**

**프롬프트**:
```
"Spring Boot 3.0 프로젝트에서 사용자 등록 서비스(UserRegistrationService)에 대한 
JUnit 5 단위 테스트를 작성해주세요.

테스트 요구사항:
- Mockito를 사용하여 UserRepository, PasswordEncoder, EmailService 의존성 모킹
- 다음 시나리오에 대한 테스트 케이스 작성:
  1. 성공적인 사용자 등록
  2. 이메일 중복 시 예외 발생
  3. 유효하지 않은 비밀번호 입력 시 예외 발생
  4. 이메일 서비스 실패 시 대응

추가 요구사항:
- @ExtendWith(MockitoExtension.class) 사용
- BDDMockito 스타일 구문 사용(given/when/then)
```

<!-- _footer: "" -->

<aside>page: 29</aside>

---
<!-- _header: 상황별 프롬프트 예제 -->

## **예제 6: 보안 취약점 방어 코드 작성**

**프롬프트**:
```
"Spring Boot 3.0과 Spring Security 6.0을 사용하여 사용자 입력을 받는 REST API 엔드
포인트에서 다음 보안 취약점을 방어하는 
코드를 구현해주세요:

1. SQL 인젝션 방어:
   - JPA/Hibernate의 parameterized 쿼리 사용 방법
   - 사용자 입력에 대한 유효성 검증

2. XSS(Cross-Site Scripting) 방어:
   - 입력 데이터 이스케이핑
   - Content-Security-Policy 헤더 설정
   - HttpOnly 및 Secure 쿠키 설정

3. CSRF(Cross-Site Request Forgery) 방어:
   - Spring Security의 CSRF 보호 기능 구성
   - CSRF 토큰 관리
```

<!-- _footer: "" -->

<aside>page: 30</aside>

---
<!-- _header: 상황별 프롬프트 예제 -->

## **예제 7: 캐시 구현**

**프롬프트**:
```
"Spring Boot 2.7과 Spring Cache, Redis를 사용하여 자주 조회되는 상품 정보를 위한 캐
싱 시스템을 구현해주세요.

요구사항:
1. 캐시 설정:
   - Redis를 캐시 저장소로 사용
   - 상품 정보 캐시의 TTL은 10분으로 설정
   - 카테고리별 상품 목록 캐시의 TTL은 30분으로 설정

2. 캐시 적용 대상:
   - 단일 상품 조회 (findById)
   - 카테고리별 상품 목록 조회 (findByCategory)
   - 인기 상품 목록 조회 (findTopProducts)

3. 캐시 무효화 전략:
   - 상품 정보 업데이트 시 관련 캐시 자동 갱신
   - 일괄 가격 변경 등 대량 업데이트 시 카테고리 캐시 삭제
```

<!-- _footer: "" -->

<aside>page: 31</aside>

---
<!-- _header: 상황별 프롬프트 예제 -->

## **예제 8: 비동기 작업 처리 서비스 구현**

**프롬프트**:
```
"Spring Boot 2.7과 Spring Async를 사용하여 대용량 파일 업로드 및 처리를 비동기적으
로 처리하는 서비스를 구현해주세요.

기능 요구사항:
1. 파일 업로드 처리:
   - 사용자가 대용량 파일(CSV, Excel) 업로드
   - 비동기로 파일 처리 작업 시작
   - 작업 ID 즉시 반환하여 사용자가 진행 상황 추적 가능

2. 진행 상태 추적:
   - 작업 ID로 현재 진행 상태 조회 가능 (대기중, 처리중, 완료, 실패)
   - 처리된 레코드 수 및 총 레코드 수 정보 제공
   - 예상 완료 시간 계산
```

<!-- _footer: "" -->

<aside>page: 32</aside>

---
<!-- _header: 상황별 프롬프트 예제 -->

## **예제 9: 메시지 큐 통합**

**프롬프트**:
```
"Spring Boot 2.7과 Spring AMQP를 사용하여 주문 처리 시스템에 RabbitMQ 기반 이벤트 
처리 아키텍처를 구현해주세요.

시스템 요구사항:
1. 이벤트 유형:
   - OrderCreatedEvent: 주문 생성 시 발생
   - PaymentConfirmedEvent: 결제 확인 시 발생
   - ShippingProcessedEvent: 배송 처리 시 발생
   - OrderCompletedEvent: 주문 완료 시 발생

2. 메시지 처리 요구사항:
   - 메시지 지속성 보장(persistent messages)
   - 메시지 수신 확인(acknowledgments)
   - 데드 레터 큐 설정
   - 실패한 메시지의 재시도 정책
```

<!-- _footer: "" -->

<aside>page: 33</aside>

---
<!-- _header: 상황별 프롬프트 예제 -->

## **예제 10: 도메인 주도 설계(DDD) 구현**

**프롬프트**:
```
"Spring Boot 3.0과 Java 17을 사용하여 전자상거래 시스템의 주문 처리 도메인을 DDD(도
메인 주도 설계) 원칙에 따라 구현해주
세요.

도메인 모델 요구사항:
1. 애그리게이트(Aggregate):
   - Order 애그리게이트: 주문 정보의 일관성과 트랜잭션 경계 관리
   - Product 애그리게이트: 상품 정보와 재고 관리
   - Customer 애그리게이트: 고객 정보 및 주소 관리

2. 엔티티(Entity):
   - Order: 주문의 핵심 엔티티, ID로 식별
   - OrderLine: 주문 내 각 상품 항목
   - Product: 상품 정보
```

<!-- _footer: "" -->

<aside>page: 34</aside>

---

> 소프트웨어 개발을 위한 프롬프트 엔지니어링
<br />
# 도입 사례
<br /><br />

<aside>page: 35</aside>

---
<!-- _header: 도입 사례 -->

## **글로벌 기업의 AI 코딩 도구 도입 사례**

- **GitHub Copilot**: 
  - 개발자 생산성 55% 향상
  - 복잡한 작업 25~30% 빠르게 완료
  - 주석 기반 자연어 인터페이스로 코드 생성

- **IBM Watson Code Assistant**:
  - 엔터프라이즈 환경 맞춤형 코드 생성
  - 회사 코딩 표준과 보안 정책 준수 지원

- **Google Gemini API**:
  - 코드 생성, 분석, 디버깅, 최적화 지원
  - 다양한 프로그래밍 언어 간 번역 기능
<!-- _footer: "" -->

<aside>page: 36</aside>


---
<!-- _header: 도입 사례 -->

## **Salesforce의 Einstein AI 활용**
<br />

- **코드 생성 및 최적화**: Salesforce 생태계 내 앱 개발 효율 향상
- **고객 데이터 분석**: 고객 행동, 구매 패턴 실시간 분석
  - Adobe Population Health: 연간 $800,000 비용 절감
- **맞춤형 제품 추천**: 개인화된 제품 추천 시스템
  - Icebreaker: 추천 제품 매출 28% 증가, 평균 주문 금액 11% 상승
- **고객 지원 자동화**: AI 에이전트로 문의 자동 분류 및 응답
  - Formula 1: 서비스 응답 속도 80% 단축
<!-- _footer: "" -->

<aside>page: 37</aside>

---
<!-- _header: 도입 사례 -->

## **국내 기업 사례**

- **삼성 SDS 'code.i'**:
  - 코드 자동 생성, 추천 및 자동 완성
  - API 문서 자동화, 레거시 코드 현대화
  - 코드 리팩토링 지원

- **LG CNS 'AI 코딩 어시스턴트'**:
  - 다양한 프로그래밍 언어 지원
  - 맞춤형 학습으로 기업 환경 최적화
  - 코드 품질 개선 및 DevOps 통합

- **네이버 클라우드 'CLOVA Studio'**:
  - 한국어 프롬프트 최적화 모델 제공
  - API 문서 작성, 코드 리뷰, 버그 수정 지원
<!-- _footer: "" -->

<aside>page: 38</aside>

---
<!-- _header: 도입 사례 -->

## **네이버 CLOVA Studio의 개발 지원 기능**
<br />

- **코드 생성 및 최적화**: 요구사항 기반 코드 자동 생성
- **API 문서화 자동화**: 코드베이스 분석 후 문서 생성
- **코드 리뷰 지원**: 품질, 보안 취약점, 성능 이슈 분석
- **디버깅 지원**: 오류 원인 진단 및 해결책 제안

- HyperCLOVA X 기반으로 한국어 맥락 이해
- RESTful API로 문장 생성, 튜닝, 스킬 트레이너 기능 제공
- 복잡한 코딩 지식 없이도 AI 모델 구축 및 적용 가능
<!-- _footer: "" -->

<aside>page: 39</aside>

---
<!-- _header: 도입 사례 -->

## **프로세스별 개선 효과 - 요구사항 분석 및 설계 단계**
<br />

- **요구사항 명확화**: 
  - 모호한 부분 식별 및 명확한 질문 생성
  - 요구사항 분석 단계의 오해 감소

- **작업 분해**: 
  - 복잡한 개발 작업을 관리 가능한 태스크로 분해
  - 프로젝트 계획 수립 시간 단축

- **아키텍처 설계 지원**: 
  - Tesla 사례: 센서 데이터 처리 아키텍처 최적화
  - 효율적인 데이터 처리 시스템 구축
<!-- _footer: "" -->

<aside>page: 40</aside>

---
<!-- _header: 도입 사례 -->

## **프로세스별 개선 효과 - 코드 개발 및 테스트 단계**

- **코드 자동 생성**: 
  - 개발자 코드 작성 속도 향상
  - 반복적인 코드 패턴 작성 효율 극대화

- **단위 테스트 자동화**: 
  - 테스트 코드 작성 시간 단축
  - 테스트 커버리지 향상

- **코드 리뷰 효율화**: 
  - Microsoft: 코드 품질 이슈 초기 발견 및 신속한 수정

- **버그 예측 및 방지**: 
  - Spotify: 배포 전 잠재적 이슈 식별
  - 운영 환경 오류 감소
<!-- _footer: "" -->

<aside>page: 41</aside>

---
<!-- _header: 도입 사례 -->

## **프로세스별 개선 효과 - 배포 및 유지보수 단계**

- **자동화된 배포 파이프라인**: 
  - 배포 시간 단축
  - 배포 실패율 감소

- **성능 모니터링 및 최적화**: 
  - Salesforce Einstein: 고객사 시스템 응답 시간 개선

- **사용자 피드백 분석**: 
  - 네이버 CLOVA Studio: 개선 우선순위 결정에 활용
  - 고객 만족도 향상

- **레거시 코드 현대화**: 
  - IBM Watson: 레거시 시스템 현대화 프로젝트 효율화
  - 비용 절감 효과
<!-- _footer: "" -->

<aside>page: 42</aside>

---

<!-- _header: 도입 사례 -->

### 조직 도입을 위한 단계별 접근법

1. **평가 및 계획**: 현재 개발 프로세스 분석, AI 도입 우선순위 영역 선정, 팀 역량 평가
2. **파일럿 프로젝트**: 측정 가능한 소규모 프로젝트 선정, 명확한 성공 지표 설정, 결과 분석
3. **프롬프트 템플릿 개발**: 용도별 템플릿 설계, 회사 코딩 표준 반영, 템플릿 최적화
4. **개발 환경 통합**: IDE 및 CI/CD 파이프라인 연동, 프롬프트 관리 시스템 구축, 품질 검증 절차 수립
5. **측정 및 최적화**: 개발 속도 및 코드 품질 지표 모니터링, 프롬프트 효과성 분석, 지속적 개선
6. **확장 및 문화 변화**: 성공사례 공유, 단계적 확산 로드맵 수립, 전문가 양성 및 조직 문화 조성


<aside>page: 43</aside>

---

<!-- _header: 결론 -->

<div class="two-blocks">
<div class="block" style="font-size:1em">
  
## **프롬프트 엔지니어링의 미래**

- 프롬프트 엔지니어링은 단순 기술을 넘어 **핵심 역량**으로 
자리매김
- AI와 인간 개발자의 **협업 모델**이 표준이 될 전망
- 모델의 발전에 따라 프롬프트 작성 방식과 활용 영역도
  함께 진화
- 장기적으로는 더 높은 수준의 추상화된 **의도 기반 소통** 방식
으로 발전
</div>
<div class="block">
  
## **SI 기업의 AI 도입 전략**

- **단계적 접근**: 소규모 프로젝트부터 시작하여 점진적으로 AI 활용 범위 확장
- **역량 내재화**: 프롬프트 엔지니어링을 핵심 기술 역량으로 육성
- **표준화**: 기업 환경에 맞는 프롬프트 템플릿과 가이드라인 개발
- **측정 및 최적화**: 생산성, 코드 품질, ROI 등 성과 지표 설정 및 추적
- **문화 조성**: AI 활용을 장려하는 조직 문화와 지식 공유 체계 구축
</div></div>

<!-- _footer: "" -->
<aside>page: 44</aside>

---

<!-- _header: 결론 -->


<div class="two-blocks">
<div class="block" style="font-size:1em">
  
## **소프트웨어 개발의 새로운 패러다임**

- AI는 개발자를 대체하는 것이 아님
  -  **역량을 확장**하는 도구
 
- 개발자의 역할이 변화
  - 코드 작성에서 **디자인과 검증**으로 무게중심 이동
 
- 개발 생산성과 품질의 획기적 향상
  -  **더 복잡한 문제 해결**에 집중 가능
 
- **창의적 문제 해결, 아키텍처 설계, 사용자 경험** 등
  -  인간 개발자의 역할 중요성 증가

</div>
<div class="block" style="font-size:0.95em">

## **미래 경쟁력 확보를 위한 제언**

- **선제적 투자**
  - 초기 생산성 저하를 감수하더라도 AI 도구 도입, 학습 투자
 
- **융합형 인재 육성**
  - 기술적 전문성 + 프롬프트 엔지니어링 역량 인재 양성
 
- **지속적 실험**
  - 다양한 AI 도구와 프롬프트 패턴의 효과성 실험 및 검증
 
- **산학협력**
  - 연구기관과 협력하여 최신 AI 기술 동향 파악 및 적용
 
- **혁신 문화**
  - 실패를 두려워하지 않는 실험 문화와 지속적 학습 환경 조성
</div></div>

<aside>page: 45</aside>

---

> 소프트웨어 개발을 위한 프롬프트 엔지니어링
<br />
# 부록. 프롬프트 엔지니어링 도구 및 프레임워크
<br /><br />

<aside>page: 46</aside>

---
<!-- _header: 프롬프트 엔지니어링 도구 및 프레임워크 -->

## **프롬프트 엔지니어링 도구 개요**
<br />

- 효과적인 프롬프트 작성, 관리, 배포를 위한 다양한 도구와 프레임워크가 존재
- 개발 워크플로우에 AI를 체계적으로 통합하는 데 도움
- 팀 내 프롬프트 공유 및 재사용성 향상
- 프롬프트 최적화 및 성능 측정 지원

<!-- _footer: "" -->

<aside>page: 47</aside>

---
<!-- _header: 프롬프트 엔지니어링 도구 및 프레임워크 -->

## **LangChain**
<br />
- **LLM 기반 애플리케이션 개발을 위한 프레임워크**
- 주요 기능:
  - **프롬프트 템플릿**: 재사용 가능한 프롬프트 패턴 정의/관리
  - **프롬프트 체이닝**: 여러 프롬프트를 연결하여 복잡한 작업 처리
  - **메모리 관리**: 대화 히스토리와 문맥 유지
  - **외부 도구 통합**: 코드 실행, DB 쿼리 등 외부 도구와 연동


<!-- _footer: "" -->

<aside>page: 48</aside>

---
<!-- _header: 프롬프트 엔지니어링 도구 및 프레임워크 -->

## **LangChain 활용 사례**
<br />

```python
from langchain.chat_models import ChatOpenAI
from langchain.prompts.chat import ChatPromptTemplate

# 프롬프트 템플릿 정의
template = """
당신은 소프트웨어 개발 전문가입니다.
다음 {language} 코드를 리팩토링하고 개선점을 설명해주세요:
{code}
"""

prompt = ChatPromptTemplate.from_template(template)
model = ChatOpenAI(model="gpt-4")

# 사용자 입력으로 프롬프트 완성
messages = prompt.format_messages(
    language="Python",
    code="def factorial(n):\n  if n == 0: return 1\n  return n * factorial(n-1)"
)

# 모델 호출 및 결과 출력
response = model.predict_messages(messages)
```

<!-- _footer: "" -->

<aside>page: 49</aside>

---
<!-- _header: 프롬프트 엔지니어링 도구 및 프레임워크 -->

## **PromptHub**
<br />

- **NLP 작업을 위한 준비된 프롬프트 공유 플랫폼**
- 주요 기능:
  - **프롬프트 라이브러리**: 다양한 개발 작업에 최적화된 프롬프트 컬렉션
  - **버전 관리**: 프롬프트 변경 이력 추적 및 관리
  - **성능 분석**: 프롬프트 효과성 측정 및 개선 지원
  - **팀 협업**: 팀 내에서 효과적인 프롬프트 공유 및 재사용

<!-- _footer: "" -->

<aside>page: 50</aside>

---
<!-- _header: 프롬프트 엔지니어링 도구 및 프레임워크 -->

## **OpenAI GPT Tools**
<br />

- **개발자가 GPT 모델을 효과적으로 활용할 수 있는 도구**
- 주요 도구:
  - **Playground**: 프롬프트 실험과 즉각적인 피드백 환경
  - **API**: 애플리케이션에 AI 기능 통합 인터페이스
  - **Fine-tuning**: 특정 작업에 모델 최적화
  - **Assistants API**: 지시사항, 대화 이력, 도구 기능을 갖춘 AI 비서 생성


<!-- _footer: "" -->
<aside>page: 51</aside>

---
<!-- _header: 프롬프트 엔지니어링 도구 및 프레임워크 -->

## **Auto-GPT**
<br />

- **목표 지향적인 자율 GPT-4 시스템**
- 고수준 목표 설정 시 AI가 자동으로 필요 작업 계획 및 실행
- 소프트웨어 개발 활용:
  - **프로젝트 자동화**: 소규모 개발 프로젝트의 자동 계획 및 실행
  - **코드 리팩토링**: 코드베이스 분석 및 개선 작업 자동화
  - **문서 생성**: 코드를 분석하여 문서 자동 생성

<!-- _footer: "" -->
<aside>page: 52</aside>

---
<!-- _header: 프롬프트 엔지니어링 도구 및 프레임워크 -->

## **Semantic Kernel**
<br />

- **Microsoft의 AI 애플리케이션 개발 SDK**
- 주요 기능:
  - **스킬 관리**: AI 기능을 모듈화된 스킬로 관리
  - **계획 생성**: 복잡한 작업을 단계별로 분해하여 실행
  - **메모리 관리**: 의미적 메모리와 컨텍스트 관리
  - **다중 모델 지원**: 다양한 AI 서비스와 통합

```csharp
// C# 예시
var kernel = Kernel.Builder.Build();
kernel.ImportSemanticSkillFromDirectory("CodeSkill", "skills/code");

var result = await kernel.RunAsync("리팩토링이 필요한 함수", 
                                 kernel.Skills.GetFunction("CodeSkill", "Refactor"));
```

<!-- _footer: "" -->

<aside>page: 53</aside>

---

> 소프트웨어 개발을 위한 프롬프트 엔지니어링
<br />
# 부록. 교육 및 학습 자원
<br /><br />

<aside>page: 54</aside>

---
<!-- _header: 교육 및 학습 자원 -->

## **프롬프트 엔지니어링 학습 리소스**

- 프롬프트 엔지니어링 역량 개발을 위한 다양한 교육 자원 존재
- 온라인 코스, 가이드, 튜토리얼, 실습 프로젝트 등 다양한 형태로 제공
- 초보자부터 전문가까지 다양한 수준의 학습 콘텐츠 활용 가능
- 실시간으로 발전하는 기술에 맞춰 지속적으로 업데이트되는 자료 필요

## **온라인 코스**

- **Codecademy**: 프롬프트 엔지니어링 코스
  - Bash 명령어, 정규 표현식, DB 쿼리 생성 등 실무 기술 포함
- **DeepLearning.AI**: ChatGPT Prompt Engineering for Developers
  - Andrew Ng 교수와 OpenAI의 Isa Fulford가 공동 개발
- **Coursera**: AI for Everyone, MLOps 과정 내 프롬프트 엔지니어링 모듈
- **Udemy**: Prompt Engineering Masterclass 등 실무 중심 과정


<!-- _footer: "" -->
<aside>page: 55</aside>

---
<!-- _header: 교육 및 학습 자원 -->

## **가이드 및 문서**
<br />

- **OpenAI 프롬프트 엔지니어링 가이드**:
  - 기본 원칙부터 고급 기법까지 포괄적인 설명
  - https://platform.openai.com/docs/guides/prompt-engineering
- **GitHub 오픈소스 레포지토리**:
  - dair-ai/Prompt-Engineering-Guide
  - f/awesome-chatgpt-prompts
- **AI 기업 기술 블로그**:
  - Anthropic, Cohere, Microsoft, Google AI 등 주요 AI 기업 블로그

<!-- _footer: "" -->
<aside>page: 56</aside>

---
<!-- _header: 교육 및 학습 자원 -->

## **실제 기업의 AI 역량 강화 사례**
<br />

### Microsoft의 AI 역량 개발 프로그램

  - **AI 기초 역량 확보**: 전 직원 대상 AI 리터러시 교육
  - **역할별 특화 교육**: 개발자, PM, 디자이너별 맞춤형 과정
  - **프로젝트 기반 학습**: 실제 업무에 AI 기술 적용 실습
  - **공유 문화 조성**: AI Day, 내부 해커톤 등 경험 공유 행사
  - **결과**: 직원 생산성 35-40% 향상, 제품 혁신 가속화

<!-- _footer: "" -->

<aside>page: 57</aside>

---
<!-- _header: 교육 및 학습 자원 -->

## **효과적인 학습 접근법**
<br />

- **이론과 실습의 균형**: 개념 이해와 실제 적용 병행
- **작은 과제부터 시작**: 간단한 코드 생성부터 시작하여 복잡한 작업으로 확장
- **피드백 루프 구축**: 생성된 결과 분석과 프롬프트 개선 반복
- **다양한 도메인 경험**: 서로 다른 개발 영역에서 프롬프트 엔지니어링 적용
- **지속적 학습**: 빠르게 발전하는 AI 기술 동향 추적 및 새로운 기법 습득
- **협업 학습**: 팀 내 지식 공유 및 공동 프롬프트 개발

<!-- _footer: "" -->

<aside>page: 59</aside>

---

> 소프트웨어 개발을 위한 프롬프트 엔지니어링
<br />
# 부록 C. 용어사전
<br /><br />

<aside>page: 60</aside>

---
<!-- _header: 부록 C. 용어사전 -->

## **용어사전 소개**
<br />

프롬프트 엔지니어링과 AI 개발 영역에서 자주 사용되는 용어들의 정의를 제공합니다. 
이 용어사전은 AI 활용 소프트웨어 개발 과정에서 필요한 주요 개념들을 이해하는 데 도움이 됩니다.

<!-- _footer: "" -->

<aside>page: 61</aside>

---
<!-- _header: 부록 C. 용어사전 -->

<div class="two-blocks">
<div class="block">

## **프롬프트 (Prompt)**

AI 모델에 입력되는 지시문 또는 질의로, 모델이 생성해야 할 출력의 형태와 내용을 안내하는 텍스트입니다. 효과적인 프롬프트는 모델이 원하는 결과를 정확하게 생성하도록 충분한 맥락과 지시를 포함해야 합니다.

</div>
<div class="block">

## **프롬프트 엔지니어링 (Prompt Engineering)**

AI 모델, 특히 대형 언어 모델(LLM)에 명확하고 효과적인 지침을 제공하여 원하는 출력을 얻는 과정입니다. 소프트웨어 개발 분야에서는 코드 생성, 디버깅, 테스트 자동화, 문서화 등 다양한 작업을 지원하는데 사용됩니다.

</div>
</div>

<!-- _footer: "" -->

<aside>page: 62</aside>

---
<!-- _header: 부록 C. 용어사전 -->

<div class="two-blocks">
<div class="block">

## **LLM (Large Language Model)**

대량의 텍스트 데이터로 학습된 대규모 언어 모델로, 텍스트 이해 및 생성 능력을 갖추고 있습니다. GPT(Generative Pre-trained Transformer), LLaMA, Claude 등이 대표적인 예시입니다. 소프트웨어 개발에서는 코드 생성, 문서화, 설계 등 다양한 영역에서 활용됩니다.

</div>
<div class="block">

## **Few-shot 프롬프팅 (Few-shot Prompting)**

AI에게 몇 가지 예시를 제공하여 원하는 결과물의 형태를 학습시키는 방법입니다. 이 방법은 모델이 특정 형식이나 스타일을 이해하고 따르도록 돕습니다.

</div>
</div>

<!-- _footer: "" -->

<aside>page: 63</aside>

---
<!-- _header: 부록 C. 용어사전 -->

<div class="two-blocks">
<div class="block">

## **제로샷 프롬프팅 (Zero-shot Prompting)**

어떠한 예시도 제공하지 않고 직접적인 지시만으로 AI가 작업을 수행하도록 하는 방법입니다. 예시 없이도 모델이 지시를 이해하고 적절한 출력을 생성할 때 사용됩니다.

</div>
<div class="block">

## **역할 기반 프롬프팅 (Role-based Prompting)**

AI에게 특정 역할을 부여하여 그 관점에서 응답하도록 하는 기법입니다. 예를 들어, "시니어 소프트웨어 엔지니어로서 이 코드를 리뷰해주세요"와 같이 사용됩니다.

</div>
</div>

<!-- _footer: "" -->

<aside>page: 64</aside>

---
<!-- _header: 부록 C. 용어사전 -->

<div class="two-blocks">
<div class="block">

## **사고연쇄 (Chain-of-Thought, COT)**

AI가 복잡한 문제를 해결할 때 단계별로 사고 과정을 나열하도록 하는 프롬프팅 기법입니다. 생각의 사슬이라고도 부릅니다. 이를 통해 더 논리적이고 정확한 결과를 얻을 수 있습니다.

</div>
<div class="block">

## **단계별 프롬프팅 (Step-by-Step Prompting)**

복잡한 작업을 작은 단계로 나누어 AI가 순차적으로 처리하도록 하는 방법입니다. 각 단계마다 명확한 지시를 제공하여 정확도를 높입니다.

</div>
</div>

<!-- _footer: "" -->

<aside>page: 65</aside>

---
<!-- _header: 부록 C. 용어사전 -->

<div class="two-blocks">
<div class="block">

## **템플릿 접근법 (Template Approach)**

반복적으로 사용할 수 있는 프롬프트 템플릿을 개발하는 방법입니다. 일관된 형식의 프롬프트를 통해 예측 가능한 결과를 얻을 수 있습니다.

</div>
<div class="block">

## **LangChain**

LLM 기반 애플리케이션 개발을 위한 프레임워크로, 프롬프트 엔지니어링을 쉽게 구현할 수 있습니다. 데이터 검색, 체인 생성, 외부 도구 연동 등의 기능을 제공합니다.

</div>
</div>

<!-- _footer: "" -->

<aside>page: 66</aside>

---
<!-- _header: 부록 C. 용어사전 -->

<div class="two-blocks">
<div class="block">

## **RAG (Retrieval-Augmented Generation)**

외부 데이터베이스나 지식 저장소에서 관련 정보를 검색하여 LLM의 응답 생성을 보강하는 기술입니다. 이를 통해 최신 정보나 특정 도메인 지식을 활용할 수 있습니다.

</div>
<div class="block">

## **프롬프트 인젝션 (Prompt Injection)**

악의적인 입력을 통해 AI 시스템의 보안을 우회하거나 의도하지 않은 출력을 유도하는 공격 방법입니다. 보안 관점에서 중요하게 다뤄야 할 위험 요소입니다.

</div>
</div>

<!-- _footer: "" -->

<aside>page: 67</aside>

---
<!-- _header: 부록 C. 용어사전 -->

<div class="two-blocks">
<div class="block">

## **파인튜닝 (Fine-tuning)**

사전 학습된 AI 모델을 특정 작업이나 도메인에 맞게 추가 학습시키는 과정입니다. 프롬프트 엔지니어링만으로는 한계가 있을 때 활용됩니다.

</div>
<div class="block">

## **RLHF (Reinforcement Learning from Human Feedback)**

인간 피드백을 기반으로 강화 학습을 적용하여 AI 모델의 출력 품질을 향상시키는 방법입니다. 특히 AI의 응답이 인간의 선호도와 가치에 부합하도록 조정하는 데 사용됩니다.

</div>
</div>

<!-- _footer: "" -->

<aside>page: 68</aside> 